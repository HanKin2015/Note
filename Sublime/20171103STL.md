---
layout: '[default_layout]'   
title: STL介绍               
date: 2017-10-14 21:36:41  
toc: true                  
tags:                        
- STL
- C++

categories:                  
- STL

---

# STL(模板库)
STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。
STL的版本很多，常见的有HP STL、PJ STL、 SGI STL等。
在C++标准中，STL被组织为下面的17个头文件：<algorithm>、<deque>、<functional>、<iterator>、<array>、<vector>、<list>、<forward_list>、<map>、<unordered_map>、<memory>、<numeric>、<queue>、<set>、<unordered_set>、<stack>和<utility>。

还有一些不是标准STL库的组件，如

# 为何某些公司不允许使用 C++ STL？
作者：姚冬
链接：https://www.zhihu.com/question/20201972/answer/41324520
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

说几个STL的缺点吧，虽然都是在比较极端的情况下出现，但是对于一些大项目还是会遇到的1. 代码膨胀问题每一个实例化过的模板类，都会膨胀出一份独立的代码，比如std::vector<std::string>, std::vector<int>，编译后会产生两份代码，在VC2008下，每份代码大约是3-4kb，这是因为vector比较简单代码少，如果是map则会产生30-50kb的代码，因为map里有个复杂的红黑树。对于数据处理类的代码里一般会定义很多种不同的结构体，不同的结构体放到不同的容器里，就会实例化出很多个类的代码，我见过一个项目里，这样的vector就有数百个。2. 内存使用效率问题 （以vc++2008为例）stl在内存使用效率上是比较低效的，比如std::string，它的sizeof大概是28，因为它有一个内置的16字节数组，用来做小字符串优化的，就是说低于16字节的字符串都会至少占用28字节内存，如果刚好17字节字符串，则会占用28字节+额外分配的字符串内存，额外分配的内存是一个堆块，又有很多浪费，相比用一个char *存储字符串大约多占用了一倍内存。还有map<>，每一个map的node都是一块独立分配的内存，如果是 map<int, int>呢，那就很悲剧了，为了存一个int要消耗几十个字节，很浪费的。如果元素数量有百万级，那么内存占用就很可观了，这种情况下建议自己实现allocator，做内存池。3. deep copy问题让两个容器的实例做赋值操作，看起来就一条语句，实际上容器里的每个元素都执行了一次赋值操作。如果容器里有百万级的数据，那么一个等号就产生了几百万次的构造和析构。传递参数的时候一定要用 const 引用，赋值可以用 swap代替。4. 隐式类型转换比如 有个函数void doSomething(const std::string &str);调用的时候   doSomething("hello");能编译执行，但是会产生一个临时的匿名的std::string实例，把"hello"复制一遍，然后在调用完成后析构掉。如果这个发生在循环体内部有可能影响性能。以上这些问题，在小程序里或者数据规模不大的时候，比如容器内元素只有几千这个规模，都不是什么大问题，那时开发效率才是重点，但是一旦有大数据stl容器会成为性能瓶颈的。我并不是主张不用STL，而是要充分了解STL的优缺点，根据应用场景做选择。

# C++难在哪
当你看完primer，甚至做了几个项目，自认为已经入门了的时候忽然有一天你开始研究别人的代码。当你看到别人写的template的时候；当你看到数字是全部要替换成宏的名字，英文要多长有多长的时候；struct全部用__attriburte__修饰的时候；运算都是位操作的时候；操作符都是重载的时候；网络都是并发缓冲线程池的时候；int只用int32_t声明的时候;继承不用普通的，各种多继承虚继承回调函数的时候；一个hello world也要写捕获异常的时候；中间一堆关键字extern,asm,auto,XXXXX_cast,volatile,explicit,register,template的时候。顿时，那些整天写int,if,else,for的小程序猿开始怀疑人生了。

作者：Carl Lee
链接：https://www.zhihu.com/question/38101493/answer/75134035
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：灵剑
链接：https://www.zhihu.com/question/38101493/answer/123729195
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

举几个例子，定义常量：C：#defineJava：constPython：都没有（哈？有变量不就行了？你说你想让它不能改？你不要改不就好了吗？我们True和False都是变量）C++：都支持！指针 vs 引用：C：指针Java：只有引用，但是栈上的变量可以传值也可以boxing/unboxingPython：只有引用（栈变量？好吃吗？）C++：都支持！不仅支持这些，我们还支持指针的引用，引用的指针，左值引用，右值引用……多态C：通过结构体和指针自己定义多态Java：单继承 + interfacePython：DuckType + 多继承（但很少用）C++：多继承，而且还支持通过结构体和指针自己定义多态，还可以让类和结构体兼容所以C++最难学C好比一个普通人在世界里探险，一旦遇到坑掉下去就没救了。Java给人插上翅膀让人可以在更安全的天空飞，但是为了保障安全，限制翅膀飞行速度，还把人腿砍了，防止人往危险的地上落。C++不仅插了翅膀，还是好几对高性能的翅膀，也没有任何保护措施，也不阻止你继续在地上走，然后还在不断往你身上加一些起落架啊、火箭喷射器啊、立体机动装置啊之类的意义不明的东西……Python：我想想，我们要不把人整个去掉，只留下翅膀算了？

# [boost （C++库）](http://www.boost.org)
Boost库是一个可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的开发引擎之一。 Boost库由C++标准委员会库工作组成员发起，其中有些内容有望成为下一代C++标准库内容。在C++社区中影响甚大，是不折不扣的“准”标准库。Boost由于其对跨平台的强调，对标准C++的强调，与编写平台无关。大部分boost库功能的使用只需包括相应头文件即可，少数（如正则表达式库，文件系统库等）需要链接库。但Boost中也有很多是实验性质的东西，在实际的开发中使用需要谨慎。
Boost库是为C++语言标准库提供扩展的一些C++程序库的总称。
Boost库由Boost社区组织开发、维护。其目的是为C++程序员提供免费、同行审查的、可移植的程序库。Boost库可以与C++标准库完美共同工作，并且为其提供扩展功能。Boost库使用Boost License来授权使用。
Boost社区建立的初衷之一就是为C++的标准化工作提供可供参考的实现，Boost社区的发起人Dawes本人就是C++标准委员会的成员之一。在Boost库的开发中，Boost社区也在这个方向上取得了丰硕的成果。在送审的C++标准库TR1中，有十个Boost库成为标准库的候选方案。在更新的TR2中，有更多的Boost库被加入到其中。从某种意义上来讲，Boost库成为具有实践意义的准标准库。
可下载Boost C++ Libraries安装boost库。大部分boost库功能的使用只需包括相应头文件即可，少数（如正则表达式库，文件系统库等）需要链接库。里面有许多具有工业强度的库，如graph库。

# 
http://purecpp.org/







