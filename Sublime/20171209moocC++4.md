---
layout: '[default_layout]'   
title: C++远征之封装篇(下)       
date: 2017-12-09 14:47:41  
toc: true                  
tags:                        
- C++

categories:                  
- C++

---
# 简介
本课程是真正跨入C++面向对象之门，讲述了对象数组、成员、指针，this指针，常对象、引用、指针、成员函数以及深拷贝和浅拷贝，课程的最后讲述了一个迷宫案例，通过这个案例可以将C++所学知识融会贯通，所有知识均通过编码实践的方式讲解到操作层面，力求即学即会。
<!--more-->
# 第1章 概述
## 1-1 C++封装概述(03:01)
“类”和“对象”，它们呢是我们封装篇大戏中的领衔主演，不过咱们的“类”呢是抽象派，玩的呢就是概念，“对象”呢则真实而具体。那么有了主角之后呢，我们还是需要一些配角帮衬着剧情才够热闹，所以呢我们下面隆重为大家介绍各位配角。
配角：
1“数据成员和成员函数”:它们构成了精彩而完整的“类”。
2“构造函数和析构函数”:它们呢描述了“对象”的生生死死。
3“对象的复制与赋值”:使“类”的定义充满艺术。
4“对象的数组与对象指针”:将应用形态发挥得淋漓尽致。
5“this指针”:它贯穿于我们这部大戏的始终却很少崭露头角，它的加入使“类”与“对象”得以有机结合，更是为封装篇画龙点睛。
大家学完了这些之后相信大家的思维模式呢就逐步地从面向过程转向面向对象

# 第2章 对象成员与对象数组
## 2-1 [C++]对象数组(06:08)
中内存被销毁是在整个main函数执行完后销毁；
而堆中由指针P所指向的内存是可手动控制何时销毁（利用delete ）可通过此来显示析构函数的存在；

共执行了6次构造函数，栈中（数组）3次，堆中（new申请）3次
![](https://img4.mukewang.com/5a463dec0001dffa12800720.jpg)
从堆中申请数组的之后 想要删除申请的内存 为什么要在delete后面加中括号呢 因为申请的内存是数组 如果不加中括号的话 那么释放的内存只是数组中的第一个元素 析构函数只执行了一次 必要要加中括号才能释放数组中所申请的所有的内存 调用全部的析构函数。否则就会出现`内存泄漏`的情况。

## 2-5 [C++]对象成员(07:27)
对象成员：顾名思义就是一个类里的[成员]含有另一个[类]，如图中看出是在line的类中含有coordinate。
注意：实例化过程是先定义产生对象成员的类，然后再产生含对象成员的类（先实例化A、在实例化B、最后实例化Line），销毁的顺序相反。
当类coor的对象作为类line的成员时，实例化line时，先实例化coor，再实例化line，
删除line时，先删除line，再删除coor
想用line的参数来初始化coor时，必须使用初始化列表，`因为系统不知道是先实例化哪一个，初始参数赋值给哪一个对象。还有原因是对象的构造函数需要赋值`
![](https://img2.mukewang.com/5a2fcba30001913812800720.jpg)
![](https://img4.mukewang.com/59f32e250001fad512800720.jpg)

# 第3章 深拷贝与浅拷贝
## 3-1 [C++]深拷贝浅拷贝(07:26)
我们希望拷贝的时候，指向不同的内存，不是简单的拷贝地址。而是将指针所指内存的每一个元素，依次拷贝过 来。当进行数据拷贝时，不是简单的做值的拷贝，而是将堆中内存的数据也进行拷贝。  我们把这种拷贝模式称为深拷贝。

 当我们去销毁arr1的时候，为了避免内存泄漏，肯定会释放掉么arr1的m_pArr所指向的内存。 我们已经释放掉这段内存了，这是如果我们再去销毁arr2这个对象的时候。我们也会释放掉arr2的m_pArr所指向的内存。同一块内存被释放了了两次。肯定就会出现问题。计算机会崩溃的。

之前的拷贝称为浅拷贝。指针在浅拷贝时还是会有问题的。arr1和arr2共同指向同一段内存，如果已经给arr1赋值了，这时候给arr2赋值的话，就会覆盖掉arr1写的值。

## 3-3 [C++]深拷贝实践(13:22)
system("pause")

# 第4章 对象指针
## 4-1 [C++]对象指针(04:01)
同样的访问限定符（如public）可以出现多次。用指针新建对象的时候，如果是默认的构造函数，后面的括号可以写可不写。
将*p括起来就变成了一个对象（*p）,访问的时候就可以以对象的方式 . 访问数据成员了。
p1->和（*p1）是一样使用的
对象指针往往会指向一段内存，如果内存是用new从堆中申请来的，使用结束之后一定要用delete归还给系统，否则会内存泄漏。
快捷键 注释：先选定内容，然后Ctrl+K+C。

## 4-6 [C++]this指针(12:07)
需要一种技术，能够标记出参数和数据成员。this指针。指向对象自身数据的指针。this写在哪里，就是谁的地址。this表达什么意思，取决于他在什么位置。

this指针就是指向自身数据的指针
同一个类，在实例化数个之后，对象的成员属性会分别放在内存的不同区域，但是这些成员函数会储存在同一片区域（这片区域在内存中叫代码区）
既然函数的逻辑代码都是以二进制的方式存储在代码区，参数中也没有数据成员，那么在调用数据成员的时候，怎么可能成功呢？
更重要的是，当存在多个对象的时候，函数该如何确定该调用哪个对象的数据成员呢？
要解决这个问题，归功于this指针。
编译时编译器自动为每个成员函数的参数列表都添加一个this 指针
当实例化对象并且使用它们的成员函数时 ，this指针就代表这个对象本身的地址
用this指向自身数据成员
this指代的是哪个类，取决于this位于哪个类中

this指针的作用就是：解决了参数和数据成员重名的问题，让计算机清楚是参数传给了数据成员；
this指针一般都是系统默认调用，以防止在实例化对象调用成员函数的时候出现错误，保证一一对应，当数据成员和构造函数中的形参名字相同是，计算机会分不清楚谁给谁赋值，这是需要人工加上this指针，用来区别。

## 4-8 [C++]this指针实践（二）(09:23)
返回对象指针，指针的值指向的是对象的地址，如果函数声明的时候只是返回类名，该类是一个临时的对象，和在主函数中实例化的对象并不一样。所以这里定义了一个引用可以返回实例化的对象。

返回值类型是Array类的对象。return *this  返回值是另一个对象，并不是原来的那个对象。想要返回这个对象本身，可以使用返回引用（Array&）和返回this这个指针（Array*）。这样就可以在调用成员函数后再接着调用其他成员函数。

对象各自的this指针指向各自对象的首地址，所以不同对象的this指针一定指向不同的内存地址

# 第5章 const再现江湖
## 5-1 常对象成员和常成员函数...(07:30)
常成员函数，编译器会理解成，this指针用const修饰。这时已经变成了常指针，通过常指针改变该指针指向的数据肯定是不被允许的。

常成员函数不能改变数据成员的值。当我们定义change这个成员函数的时候。看上去貌似没有任何的参数。实际上却隐含着参数。这个参数就是this指针。

要想调用常成员函数，就要初始化一个常变量，这时候调用的函数就是常成员函数。

## 5-4 常指针与常引用(06:56)
const加在星号后面，表示指针指向不能变动，可以调动成员函数，但不能再给指针赋别的对象。
第一个错在：常对象只能调用常成员函数，这里getX()不是const类型
第二个错在： 常指针只有只读权限，getY（）里面指针读写权限，所以不可以、

常指针和常引用用于对象时，只能调用常成员函数。
const放在*和变量名之间，指针的指向就是固定的了。但是他指向的地址的内容具有读写权限。但是他不能指向其他位置。pCool->getY();是正确的。下一行是错误的。
![](https://img3.mukewang.com/5a6549ff00010b7312800720.jpg)
## 5-5 练习题
常对象只能调用常成员函数

普通对象可以调用普通成员函数和常成员函数
常指针和常引用都只能调用常成员函数
一个对象可以有多个常对象引用

```
#include <bits/stdc++.h>
using namespace std;
class Coordinate
{

public:
    Coordinate(int x, int y)
    {
        // 设置X,Y的坐标
        m_iX = x;
        m_iY = y;
    }
    // 实现常成员函数
    void printInfo() const
    {
        cout << '(' << m_iX << ',' << m_iY << ')' << endl;
    }
public:
    int m_iX;
    int m_iY;
};


int main(void)
{
    const Coordinate coor(3, 5);

    // 创建常指针p
    const Coordinate *p = &coor;
    // 创建常引用c
    const Coordinate &c = coor;

    coor.printInfo();
    p->printInfo();
    c.printInfo();

    return 0;
}
```

# 第6章 学以致用
## 6-1 开篇案例(12:56)

